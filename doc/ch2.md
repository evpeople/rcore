# 从这一章学到的
1. 之所以采用特权模式，是因为人们希望一个小的应用程序的错误不会影响其他的应用程序，需要一个程序可以终止其他的应用程序。

在上一章已经实现了操作系统在用户态执行，*实际上，上一章只有一种状态*，本章实现的批处理系统，需要操作系统在内核态执行，一般的程序运行在用户态。实际上就是编写一些可以在裸机上运行的程序吗，通过修改linker.ld将其这些程序移动到指定的内存位置。
同时在实现用户态程序的输出时，不可避免需要跨特权级做系统调用。

在另一方面，qemu模拟器之前只是读入操作系统，然后操作系统call shutdown，现在需要他读入的操作系统能做批处理任务，所以需要把应用程序和操作系统的两个程序连接在一起。并且操作系统程序还能找到用户态应用程序的位置。

这里引入了ELF格式执行文件和Binary格式的概念
> BIN文件是直接的二进制文件，内部没有地址标记。bin文件内部数据按照代码段或者数据段的物理空间地址来排列。一般用编程器烧写时从00开始，而如果下载运行，则下载到编译时的地址即可。


> ELF文件是用加载器解析ELF然后执行的，是可重定位的目标文件。

既然目前的操作系统没有实现可重定位的功能，所以需要把这些小程序修改外Binary格式，通过rust-objcopy进行修改。此时这些用户态的应用程序只要放在正确的内存就能正确的执行了。但是需要操作系统启动他们的执行，所以操作系统还需要知道Binary的位置，通过编译信息中的变量和标号。然后将其安排到对应的位置。

在Binary执行前，需要操作系统安排一系列执行环境所需的资源。

## 应用程序设计

内核镜像os.bin是加载到0x80200000 *由RustSBI确定的*
外部应用程序加载到0x80400000
1. 对于用户态的程序，设计的编写过程和ch1中的操作系统设计一样，提供一个运行时环境库，然后编写链接器脚本，说明程序的内存布局。

2. 汇编中的弱连接`#[linkage = "weak"]`，最后连接的时候，如果应用程序和库*采用弱连接的地方*有相同的符号，会采用应用的符号，同时没有相同符号的时候，也能编译通过。